{% extends 'core/wizards/_base.html' %}
{% load i18n bootstrap %}

{% block wizard_fields %}
<h1 class="sr-only">{% trans "Transcribe Images" %} - {% trans "Automatic Transcription Wizard" %}</h1>
{% endblock %}

{% block wizard_help %}
<p>{% trans "Make sure that the segmentation is good before going forward because resegmenting will delete all bound transcriptions." %}
{% endblock %}

{% block wizard_fields %}
{# ðŸ†• BiblIA Enhancement: OCR Engine Selector #}
<div class="form-group">
  <h5><i class="fas fa-cog"></i> {% trans "OCR Engine" %}</h5>
  <select id="ocr-engine-selector" class="form-control" name="engine">
    <option value="kraken" selected>Kraken (Default HTR/OCR)</option>
    <option value="tesseract">Tesseract OCR</option>
  </select>
  <small class="form-text text-muted">
    {% trans "Choose the OCR engine: Kraken for handwritten text (HTR) or Tesseract for printed text" %}
  </small>
</div>

<div class="form-group">
  <h5><i class="fas fa-brain"></i> {% trans "Select a model" %}</h5>
  {% render_field transcribe_form.model class="js-proc-settings" data_document=document.pk %}
  <small class="form-text text-muted">
    <span id="model-count-info"></span>
  </small>
</div>

<div class="form-group">
  <h5><i class="fas fa-file-alt"></i> {% trans "Select a transcription" %}</h5>
  {% render_field transcribe_form.transcription %}
  <small class="form-text text-muted">
    {% trans "Choose an existing transcription to update, or leave blank to create a new one" %}
  </small>
</div>

{# JavaScript for filtering models by engine #}
<script>
(function() {
  'use strict';
  
  const engineSelector = document.getElementById('ocr-engine-selector');
  const modelSelect = document.querySelector('[name="model"]') || 
                      document.getElementById('id_model') ||
                      document.querySelector('.js-proc-settings');
  
  if (!engineSelector || !modelSelect) {
    console.warn('Engine selector or model select not found');
    return;
  }
  
  // Store original options with engine metadata
  const allOptions = Array.from(modelSelect.options).map(opt => ({
    element: opt.cloneNode(true),
    text: opt.textContent,
    value: opt.value,
    // Detect engine from model name or optgroup
    engine: detectEngine(opt)
  }));
  
  function detectEngine(option) {
    const text = option.textContent.toLowerCase();
    const parent = option.parentElement;
    
    // Check if in optgroup
    if (parent && parent.tagName === 'OPTGROUP') {
      const label = parent.label.toLowerCase();
      if (label.includes('tesseract')) return 'tesseract';
      if (label.includes('kraken')) return 'kraken';
    }
    
    // Check filename extension in value or text
    if (text.includes('.traineddata') || text.includes('tesseract')) {
      return 'tesseract';
    }
    
    // Default to kraken
    return 'kraken';
  }
  
  function filterModelsByEngine(selectedEngine) {
    // Clear current options
    modelSelect.innerHTML = '';
    
    // Add filtered options
    const filtered = allOptions.filter(opt => 
      !opt.value || opt.engine === selectedEngine
    );
    
    filtered.forEach(opt => {
      modelSelect.appendChild(opt.element.cloneNode(true));
    });
    
    // Update count info
    const countInfo = document.getElementById('model-count-info');
    if (countInfo) {
      const count = filtered.filter(o => o.value).length;
      countInfo.textContent = count + ' ' + 
        (selectedEngine === 'tesseract' ? 'Tesseract' : 'Kraken') + 
        ' models available';
      countInfo.style.color = count > 0 ? '#28a745' : '#dc3545';
    }
    
    // Trigger change event
    modelSelect.dispatchEvent(new Event('change'));
  }
  
  // Listen to engine changes
  engineSelector.addEventListener('change', function() {
    filterModelsByEngine(this.value);
  });
  
  // Initialize with Kraken (default)
  filterModelsByEngine('kraken');
})();
</script>
{% endblock %}

{% block wizard_submit %}{% trans "Transcribe" %}{% endblock %}
